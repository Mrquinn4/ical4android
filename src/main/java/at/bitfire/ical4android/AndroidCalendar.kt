/*
 * Copyright Â© Ricki Hirner (bitfire web engineering).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Public License v3.0
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/gpl.html
 */

package at.bitfire.ical4android

import android.accounts.Account
import android.annotation.SuppressLint
import android.content.ContentProviderClient
import android.content.ContentUris
import android.content.ContentValues
import android.database.DatabaseUtils
import android.net.Uri
import android.os.RemoteException
import android.provider.CalendarContract
import android.provider.CalendarContract.*
import java.io.FileNotFoundException
import java.util.*

/**
 * Represents a locally stored calendar, containing AndroidEvents (whose data objects are Events).
 * Communicates with the Android Contacts Provider which uses an SQLite
 * database to store the events.
 */
abstract class AndroidCalendar<out T: AndroidEvent>(
        val account: Account,
        val provider: ContentProviderClient,
        val eventFactory: AndroidEventFactory<T>,
        val id: Long
) {

    var name: String? = null
    var displayName: String? = null
    var color: Int? = null
    var isSynced = true
    var isVisible = true

    /**
     * Those CalendarContract.Events columns will always be fetched by queryEvents().
     * Must at least contain Events._ID!
     */
    protected open fun eventBaseInfoColumns() = arrayOf(Events._ID)


    companion object {

        @JvmStatic
        @Throws(CalendarStorageException::class)
        fun create(account: Account, provider: ContentProviderClient, info: ContentValues): Uri {
            info.put(Calendars.ACCOUNT_NAME, account.name)
            info.put(Calendars.ACCOUNT_TYPE, account.type)

            // these values are generated by ical4android
            info.put(Calendars.ALLOWED_AVAILABILITY, "${Events.AVAILABILITY_BUSY},${Events.AVAILABILITY_FREE},${Events.AVAILABILITY_TENTATIVE}")
            info.put(Calendars.ALLOWED_ATTENDEE_TYPES, "${Attendees.TYPE_NONE},${Attendees.TYPE_OPTIONAL},${Attendees.TYPE_REQUIRED},${Attendees.TYPE_RESOURCE}")

            Constants.log.info("Creating local calendar: " + info.toString())
            try {
                return provider.insert(syncAdapterURI(Calendars.CONTENT_URI, account), info)
            } catch(e: RemoteException) {
                throw CalendarStorageException("Couldn't create calendar", e)
            }
        }

        @JvmStatic
        fun insertColors(provider: ContentProviderClient, account: Account) {
            provider.query(syncAdapterURI(Colors.CONTENT_URI, account), arrayOf(Colors.COLOR_KEY), null, null, null)?.use { cursor ->
                if (cursor.count == EventColor.values().size)
                // colors already inserted and up to date
                    return
            }

            Constants.log.info("Inserting event colors for account $account")
            val values = ContentValues(5)
            values.put(CalendarContract.Colors.ACCOUNT_NAME, account.name)
            values.put(CalendarContract.Colors.ACCOUNT_TYPE, account.type)
            values.put(Colors.COLOR_TYPE, Colors.TYPE_EVENT)
            for (color in EventColor.values()) {
                values.put(Colors.COLOR_KEY, color.name)
                values.put(Colors.COLOR, color.rgba)
                provider.insert(syncAdapterURI(Colors.CONTENT_URI, account), values)
            }
        }

        @JvmStatic
        fun removeColors(provider: ContentProviderClient, account: Account) {
            Constants.log.info("Removing event colors from account $account")

            // unassign colors from events
            val values = ContentValues(1)
            values.putNull(Events.EVENT_COLOR_KEY)
            provider.update(syncAdapterURI(Events.CONTENT_URI, account), values,
                    "${Events.EVENT_COLOR_KEY} IS NOT NULL AND ${Events.ACCOUNT_TYPE}=? AND ${Events.ACCOUNT_NAME}=?",
                    arrayOf(account.type, account.name))

            // remove color entries
            provider.delete(syncAdapterURI(Colors.CONTENT_URI, account), null, null)
        }

        @SuppressLint("Recycle")
        @JvmStatic
        @Throws(FileNotFoundException::class, CalendarStorageException::class)
        fun<T: AndroidCalendar<AndroidEvent>> findByID(account: Account, provider: ContentProviderClient, factory: AndroidCalendarFactory<T>, id: Long): T {
            val iterCalendars = CalendarContract.CalendarEntity.newEntityIterator(
                    provider.query(syncAdapterURI(ContentUris.withAppendedId(CalendarContract.CalendarEntity.CONTENT_URI, id), account), null, null, null, null)
            )
            try {
                if (iterCalendars.hasNext()) {
                    val values = iterCalendars.next().entityValues
                    val calendar = factory.newInstance(account, provider, id)
                    calendar.populate(values)
                    return calendar
                }
            } catch(e: RemoteException) {
                throw CalendarStorageException("Couldn't query calendars", e)
            } finally {
                iterCalendars.close()
            }
            throw FileNotFoundException()
        }

        @SuppressLint("Recycle")
        @JvmStatic
        @Throws(CalendarStorageException::class)
        fun<T: AndroidCalendar<AndroidEvent>> find(account: Account, provider: ContentProviderClient, factory: AndroidCalendarFactory<T>, where: String?, whereArgs: Array<String>?): List<T> {
            val iterCalendars = CalendarContract.CalendarEntity.newEntityIterator(
                    provider.query(syncAdapterURI(CalendarContract.CalendarEntity.CONTENT_URI, account), null, where, whereArgs, null)
            )
            try {
                val calendars = LinkedList<T>()
                while (iterCalendars.hasNext()) {
                    val values = iterCalendars.next().entityValues
                    val calendar = factory.newInstance(account, provider, values.getAsLong(Calendars._ID))
                    calendar.populate(values)
                    calendars += calendar
                }
                return calendars
            } catch(e: RemoteException) {
                throw CalendarStorageException("Couldn't query calendars", e)
            } finally {
                iterCalendars.close()
            }
        }


        fun syncAdapterURI(uri: Uri, account: Account) = uri.buildUpon()
                .appendQueryParameter(Calendars.ACCOUNT_NAME, account.name)
                .appendQueryParameter(Calendars.ACCOUNT_TYPE, account.type)
                .appendQueryParameter(CalendarContract.CALLER_IS_SYNCADAPTER, "true")
                .build()!!
    }


    open protected fun populate(info: ContentValues) {
        name = info.getAsString(Calendars.NAME)
        displayName = info.getAsString(Calendars.CALENDAR_DISPLAY_NAME)

        color = info.getAsInteger(Calendars.CALENDAR_COLOR)

        isSynced = info.getAsInteger(Calendars.SYNC_EVENTS) != 0
        isVisible = info.getAsInteger(Calendars.VISIBLE) != 0
    }


    @Throws(CalendarStorageException::class)
    fun update(info: ContentValues) {
        try {
            provider.update(syncAdapterURI(calendarSyncURI()), info, null, null)
        } catch (e: RemoteException) {
            throw CalendarStorageException("Couldn't update calendar", e)
        }
    }

    @Throws(CalendarStorageException::class)
    fun delete() = try {
        provider.delete(calendarSyncURI(), null, null)
    } catch (e: RemoteException) {
        throw CalendarStorageException("Couldn't delete calendar", e)
    }


    @Throws(CalendarStorageException::class)
    protected fun queryEvents(where: String? = null, whereArgs: Array<String>? = null): List<T> {
        val where = "(${where ?: "1"}) AND " + Events.CALENDAR_ID + "=?"
        val whereArgs = (whereArgs ?: arrayOf()) + id.toString()

        val events = LinkedList<T>()
        try {
            provider.query(
                    syncAdapterURI(Events.CONTENT_URI),
                    eventBaseInfoColumns(),
                    where, whereArgs, null)?.use { cursor ->
                while (cursor.moveToNext()) {
                    val baseInfo = ContentValues(cursor.columnCount)
                    DatabaseUtils.cursorRowToContentValues(cursor, baseInfo)
                    events += eventFactory.newInstance(this, baseInfo.getAsLong(Events._ID), baseInfo)
                }
            }
        } catch (e: RemoteException) {
            throw CalendarStorageException("Couldn't query calendar events", e)
        }
        return events
    }


    fun syncAdapterURI(uri: Uri) = uri.buildUpon()
            .appendQueryParameter(Calendars.ACCOUNT_NAME, account.name)
            .appendQueryParameter(Calendars.ACCOUNT_TYPE, account.type)
            .appendQueryParameter(CalendarContract.CALLER_IS_SYNCADAPTER, "true")
            .build()!!

    fun calendarSyncURI() = syncAdapterURI(ContentUris.withAppendedId(Calendars.CONTENT_URI, id))

}
