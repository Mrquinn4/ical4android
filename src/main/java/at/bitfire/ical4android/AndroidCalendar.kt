/*
 * Copyright (c) 2013 â€“ 2015 Ricki Hirner (bitfire web engineering).
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 */
package at.bitfire.ical4android

import android.accounts.Account
import android.content.ContentProviderClient
import android.content.ContentUris
import android.content.ContentValues
import android.content.EntityIterator
import android.database.DatabaseUtils
import android.net.Uri
import android.os.RemoteException
import android.provider.CalendarContract
import android.provider.CalendarContract.*
import org.apache.commons.lang3.ArrayUtils
import java.io.FileNotFoundException
import java.util.*

/**
 * Represents a locally stored calendar, containing AndroidEvents (whose data objects are Events).
 * Communicates with the Android Contacts Provider which uses an SQLite
 * database to store the events.
 */
abstract class AndroidCalendar(
        val account: Account,
        val provider: ContentProviderClient,
        val eventFactory: AndroidEventFactory<AndroidEvent>,
        val id: Long
) {

    private var name: String? = null
    private var displayName: String? = null
    private var color: Int? = null
    private var isSynced = true
    private var isVisible = true

    /**
     * Those CalendarContract.Events columns will always be fetched by queryEvents().
     * Must at least contain Events._ID!
     */
    protected open fun eventBaseInfoColumns() = arrayOf(Events._ID)


    companion object {


        /* class methods, constructor */

        @JvmStatic
        @Throws(CalendarStorageException::class)
        fun create(account: Account, provider: ContentProviderClient, info: ContentValues): Uri {
            info.put(Calendars.ACCOUNT_NAME, account.name)
            info.put(Calendars.ACCOUNT_TYPE, account.type)

            // these values are generated by ical4android
            info.put(Calendars.ALLOWED_AVAILABILITY, "${Events.AVAILABILITY_BUSY},${Events.AVAILABILITY_FREE},${Events.AVAILABILITY_TENTATIVE}")
            info.put(Calendars.ALLOWED_ATTENDEE_TYPES, "${Attendees.TYPE_NONE},${Attendees.TYPE_OPTIONAL},${Attendees.TYPE_REQUIRED},${Attendees.TYPE_RESOURCE}")

            Constants.log.info("Creating local calendar: " + info.toString())
            try {
                return provider.insert(syncAdapterURI(Calendars.CONTENT_URI, account), info)
            } catch(e: RemoteException) {
                throw CalendarStorageException("Couldn't create calendar", e)
            }
        }

        @JvmStatic
        @Throws(FileNotFoundException::class, CalendarStorageException::class)
        fun<T: AndroidCalendar> findByID(account: Account, provider: ContentProviderClient, factory: AndroidCalendarFactory<T>, id: Long): T {
            var iterCalendars: EntityIterator? = null
            try {
                iterCalendars = CalendarContract.CalendarEntity.newEntityIterator(
                        provider.query(syncAdapterURI(ContentUris.withAppendedId(CalendarContract.CalendarEntity.CONTENT_URI, id), account), null, null, null, null)
                )

                if (iterCalendars.hasNext()) {
                    val values = iterCalendars.next().entityValues

                    val calendar = factory.newInstance(account, provider, id)
                    calendar.populate(values)
                    return calendar
                }
            } catch(e: RemoteException) {
                throw CalendarStorageException("Couldn't query calendars", e)
            } finally {
                iterCalendars?.close()
            }
            throw FileNotFoundException()
        }

        @JvmStatic
        @Throws(CalendarStorageException::class)
        fun<T: AndroidCalendar> find(account: Account, provider: ContentProviderClient, factory: AndroidCalendarFactory<T>, where: String?, whereArgs: Array<String>?): List<T> {
            var iterCalendars: EntityIterator? = null
            try {
                iterCalendars = CalendarContract.CalendarEntity.newEntityIterator(
                        provider.query(syncAdapterURI(CalendarContract.CalendarEntity.CONTENT_URI, account), null, where, whereArgs, null)
                )

                val calendars = LinkedList<T>()
                while (iterCalendars.hasNext()) {
                    val values = iterCalendars.next().entityValues

                    val calendar = factory.newInstance(account, provider, values.getAsLong(Calendars._ID))
                    calendar.populate(values)
                    calendars.add(calendar)
                }
                return calendars
            } catch(e: RemoteException) {
                throw CalendarStorageException("Couldn't query calendars", e)
            } finally {
                iterCalendars?.close()
            }
        }


        fun syncAdapterURI(uri: Uri, account: Account) = uri.buildUpon()
                .appendQueryParameter(Calendars.ACCOUNT_NAME, account.name)
                .appendQueryParameter(Calendars.ACCOUNT_TYPE, account.type)
                .appendQueryParameter(CalendarContract.CALLER_IS_SYNCADAPTER, "true")
                .build()!!
    }


    protected fun populate(info: ContentValues) {
        name = info.getAsString(Calendars.NAME)
        displayName = info.getAsString(Calendars.CALENDAR_DISPLAY_NAME)

        color = info.getAsInteger(Calendars.CALENDAR_COLOR)

        isSynced = info.getAsInteger(Calendars.SYNC_EVENTS) != 0
        isVisible = info.getAsInteger(Calendars.VISIBLE) != 0
    }


    @Throws(CalendarStorageException::class)
    fun update(info: ContentValues) {
        try {
            provider.update(syncAdapterURI(calendarSyncURI()), info, null, null)
        } catch (e: RemoteException) {
            throw CalendarStorageException("Couldn't update calendar", e)
        }
    }

    @Throws(CalendarStorageException::class)
    fun delete() = try {
        provider.delete(calendarSyncURI(), null, null)
    } catch (e: RemoteException) {
        throw CalendarStorageException("Couldn't delete calendar", e)
    }


    @Throws(CalendarStorageException::class)
    protected fun queryEvents(where: String?, whereArgs: Array<String>? = null): List<AndroidEvent> {
        val where = if (where == null)
            ""
        else
            "($where) AND " + Events.CALENDAR_ID + "=?"
        val whereArgs = ArrayUtils.add(whereArgs, id.toString())

        try {
            provider.query(
                    syncAdapterURI(Events.CONTENT_URI),
                    eventBaseInfoColumns(),
                    where, whereArgs, null).use { cursor ->
                val events = LinkedList<AndroidEvent>()
                while (cursor != null && cursor.moveToNext()) {
                    val baseInfo = ContentValues(cursor.columnCount)
                    DatabaseUtils.cursorRowToContentValues(cursor, baseInfo)

                    val event = eventFactory.newInstance(this, cursor.getLong(0), baseInfo)
                    events.add(event)
                }
                return events
            }
        } catch (e: RemoteException) {
            throw CalendarStorageException("Couldn't query calendar events", e)
        }
    }


    fun syncAdapterURI(uri: Uri) = uri.buildUpon()
            .appendQueryParameter(Calendars.ACCOUNT_NAME, account.name)
            .appendQueryParameter(Calendars.ACCOUNT_TYPE, account.type)
            .appendQueryParameter(CalendarContract.CALLER_IS_SYNCADAPTER, "true")
            .build()!!

    fun calendarSyncURI() = syncAdapterURI(ContentUris.withAppendedId(Calendars.CONTENT_URI, id))

}
